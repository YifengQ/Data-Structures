<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Project 6: NodeTree Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Project 6
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_node_tree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">NodeTree Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for NodeTree:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_node_tree.png" usemap="#NodeTree_map" alt=""/>
  <map id="NodeTree_map" name="NodeTree_map">
<area href="class_node.html" alt="Node" shape="rect" coords="0,0,68,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaffe7d72c1e5c56881854487370281a8"><td class="memItemLeft" align="right" valign="top"><a id="aaffe7d72c1e5c56881854487370281a8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node_tree.html#aaffe7d72c1e5c56881854487370281a8">NodeTree</a> ()</td></tr>
<tr class="memdesc:aaffe7d72c1e5c56881854487370281a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Default constructor for the <a class="el" href="class_node_tree.html">NodeTree</a>. <br /></td></tr>
<tr class="separator:aaffe7d72c1e5c56881854487370281a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb351a862dce80510ac48d145de2e9c"><td class="memItemLeft" align="right" valign="top"><a id="a6cb351a862dce80510ac48d145de2e9c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NodeTree</b> (const int &amp;rootItem)</td></tr>
<tr class="separator:a6cb351a862dce80510ac48d145de2e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801678afd7b236bc75687a776e979f80"><td class="memItemLeft" align="right" valign="top"><a id="a801678afd7b236bc75687a776e979f80"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NodeTree</b> (const <a class="el" href="class_node_tree.html">NodeTree</a> &amp;tree)</td></tr>
<tr class="separator:a801678afd7b236bc75687a776e979f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d1c0d70fc02fea199e9e7a81491d83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node_tree.html#ae6d1c0d70fc02fea199e9e7a81491d83">insertInorder</a> (<a class="el" href="class_node.html">Node</a> *subTreePtr, <a class="el" href="class_node.html">Node</a> *newNode)</td></tr>
<tr class="memdesc:ae6d1c0d70fc02fea199e9e7a81491d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">global variable to count the amount of nodes  <a href="#ae6d1c0d70fc02fea199e9e7a81491d83">More...</a><br /></td></tr>
<tr class="separator:ae6d1c0d70fc02fea199e9e7a81491d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5581b1e229d7310960e826a14e34f560"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node_tree.html#a5581b1e229d7310960e826a14e34f560">getRootPtr</a> ()</td></tr>
<tr class="separator:a5581b1e229d7310960e826a14e34f560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad091290982424bcc0750da7133e411"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node_tree.html#a3ad091290982424bcc0750da7133e411">~NodeTree</a> ()</td></tr>
<tr class="separator:a3ad091290982424bcc0750da7133e411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484735008677b458037b1ce114d12f1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node_tree.html#a484735008677b458037b1ce114d12f1a">isEmpty</a> (<a class="el" href="class_node.html">Node</a> *nodePtr) const</td></tr>
<tr class="memdesc:a484735008677b458037b1ce114d12f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will test if the tree is empty.  <a href="#a484735008677b458037b1ce114d12f1a">More...</a><br /></td></tr>
<tr class="separator:a484735008677b458037b1ce114d12f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711fa23ec5715b82c1a6dee780fde087"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node_tree.html#a711fa23ec5715b82c1a6dee780fde087">getHeight</a> ()</td></tr>
<tr class="memdesc:a711fa23ec5715b82c1a6dee780fde087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will get the height by calling the helper.  <a href="#a711fa23ec5715b82c1a6dee780fde087">More...</a><br /></td></tr>
<tr class="separator:a711fa23ec5715b82c1a6dee780fde087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504b5d012ccee99b85642d699396dd8f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node_tree.html#a504b5d012ccee99b85642d699396dd8f">heightHelper</a> (<a class="el" href="class_node.html">Node</a> *treePtr)</td></tr>
<tr class="separator:a504b5d012ccee99b85642d699396dd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab619ff00f2cd2362d393ad41f2844129"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node_tree.html#ab619ff00f2cd2362d393ad41f2844129">getNumberofNodes</a> (<a class="el" href="class_node.html">Node</a> *nodePtr) const</td></tr>
<tr class="memdesc:ab619ff00f2cd2362d393ad41f2844129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will return the number of nodes in the tree. It will run until both children get null.  <a href="#ab619ff00f2cd2362d393ad41f2844129">More...</a><br /></td></tr>
<tr class="separator:ab619ff00f2cd2362d393ad41f2844129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037b369c78e107b423090eab320b022f"><td class="memItemLeft" align="right" valign="top"><a id="a037b369c78e107b423090eab320b022f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getRootData</b> ()</td></tr>
<tr class="separator:a037b369c78e107b423090eab320b022f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a0aebabeac588fe08b3fb810fe74ba"><td class="memItemLeft" align="right" valign="top"><a id="aa1a0aebabeac588fe08b3fb810fe74ba"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>remove</b> (const int &amp;data)</td></tr>
<tr class="separator:aa1a0aebabeac588fe08b3fb810fe74ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa354f6975e4e1123b47a21948d00e1b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node_tree.html#aa354f6975e4e1123b47a21948d00e1b2">setRootData</a> (const int &amp;newData)</td></tr>
<tr class="separator:aa354f6975e4e1123b47a21948d00e1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa34cb3970d7ea5ed4c7861ee844b1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node_tree.html#adfa34cb3970d7ea5ed4c7861ee844b1e">setRoot</a> (<a class="el" href="class_node.html">Node</a> *root)</td></tr>
<tr class="separator:adfa34cb3970d7ea5ed4c7861ee844b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2cd480e0a50d94d26b09cfd721ac7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node_tree.html#a2e2cd480e0a50d94d26b09cfd721ac7a">add</a> (const int &amp;newData)</td></tr>
<tr class="separator:a2e2cd480e0a50d94d26b09cfd721ac7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22be831083f6970a7ba6b64fcd0995ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node_tree.html#a22be831083f6970a7ba6b64fcd0995ff">clear</a> (<a class="el" href="class_node.html">Node</a> *nodePtr)</td></tr>
<tr class="separator:a22be831083f6970a7ba6b64fcd0995ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28bcd072ea53a04712a792b6b427371c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node_tree.html#a28bcd072ea53a04712a792b6b427371c">getEntry</a> (const int &amp;anEntry)</td></tr>
<tr class="memdesc:a28bcd072ea53a04712a792b6b427371c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will find the entry and return the value, if not it will return 0.  <a href="#a28bcd072ea53a04712a792b6b427371c">More...</a><br /></td></tr>
<tr class="separator:a28bcd072ea53a04712a792b6b427371c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0617d6f4b39f495da71613a05a098e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node_tree.html#a7a0617d6f4b39f495da71613a05a098e">contains</a> (const int &amp;anEntry) const</td></tr>
<tr class="separator:a7a0617d6f4b39f495da71613a05a098e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73bd5a18b76a3741fcf49e0465622de2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node_tree.html#a73bd5a18b76a3741fcf49e0465622de2">preorderTransverse</a> (<a class="el" href="class_node.html">Node</a> *nodePtr) const</td></tr>
<tr class="memdesc:a73bd5a18b76a3741fcf49e0465622de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will preorder transverse the tree and print the data.  <a href="#a73bd5a18b76a3741fcf49e0465622de2">More...</a><br /></td></tr>
<tr class="separator:a73bd5a18b76a3741fcf49e0465622de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3973627c8a390da9b12e4bc9d4a9327d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node_tree.html#a3973627c8a390da9b12e4bc9d4a9327d">inorderTransverse</a> (<a class="el" href="class_node.html">Node</a> *nodePtr) const</td></tr>
<tr class="memdesc:a3973627c8a390da9b12e4bc9d4a9327d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will inorder transverse the tree and print the data.  <a href="#a3973627c8a390da9b12e4bc9d4a9327d">More...</a><br /></td></tr>
<tr class="separator:a3973627c8a390da9b12e4bc9d4a9327d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ddf9e2cb245c50952b9669fb328907"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node_tree.html#a09ddf9e2cb245c50952b9669fb328907">postorderTransverse</a> (<a class="el" href="class_node.html">Node</a> *nodePtr) const</td></tr>
<tr class="memdesc:a09ddf9e2cb245c50952b9669fb328907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will postorder transverse the tree and print the data.  <a href="#a09ddf9e2cb245c50952b9669fb328907">More...</a><br /></td></tr>
<tr class="separator:a09ddf9e2cb245c50952b9669fb328907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a02f5a4836ed05e0d51e946101982b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node_tree.html#a4a02f5a4836ed05e0d51e946101982b8">deleteNode</a> (<a class="el" href="class_node.html">Node</a> *nodePtr, int key)</td></tr>
<tr class="memdesc:a4a02f5a4836ed05e0d51e946101982b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will delete the node with the key.  <a href="#a4a02f5a4836ed05e0d51e946101982b8">More...</a><br /></td></tr>
<tr class="separator:a4a02f5a4836ed05e0d51e946101982b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a5469b3871672b409224ee905540c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node_tree.html#a71a5469b3871672b409224ee905540c3">minValue</a> (<a class="el" href="class_node.html">Node</a> *nodePtr)</td></tr>
<tr class="separator:a71a5469b3871672b409224ee905540c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4deaf904f4b727579020bcf6cba77a8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node_tree.html#a4deaf904f4b727579020bcf6cba77a8f">resetCount</a> ()</td></tr>
<tr class="separator:a4deaf904f4b727579020bcf6cba77a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57c84edf2b16c3fed7085413b272a62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node_tree.html#ac57c84edf2b16c3fed7085413b272a62">inorderDelete</a> (<a class="el" href="class_node.html">Node</a> *nodePtr, int)</td></tr>
<tr class="memdesc:ac57c84edf2b16c3fed7085413b272a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will delete the nodes that are equal to the nodes in BTS2.  <a href="#ac57c84edf2b16c3fed7085413b272a62">More...</a><br /></td></tr>
<tr class="separator:ac57c84edf2b16c3fed7085413b272a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_node"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_node')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_node.html">Node</a></td></tr>
<tr class="memitem:ad7a34779cad45d997bfd6d3d8043c75f inherit pub_methods_class_node"><td class="memItemLeft" align="right" valign="top"><a id="ad7a34779cad45d997bfd6d3d8043c75f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node.html#ad7a34779cad45d997bfd6d3d8043c75f">Node</a> ()</td></tr>
<tr class="memdesc:ad7a34779cad45d997bfd6d3d8043c75f inherit pub_methods_class_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor for <a class="el" href="class_node.html">Node</a>. <br /></td></tr>
<tr class="separator:ad7a34779cad45d997bfd6d3d8043c75f inherit pub_methods_class_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b85d29b3bde0f983d0a6135ca440c0a inherit pub_methods_class_node"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node.html#a6b85d29b3bde0f983d0a6135ca440c0a">Node</a> (const int &amp;anitem)</td></tr>
<tr class="separator:a6b85d29b3bde0f983d0a6135ca440c0a inherit pub_methods_class_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f4f5083e2a677525a28a5cd194178d inherit pub_methods_class_node"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node.html#a63f4f5083e2a677525a28a5cd194178d">Node</a> (const int &amp;item, <a class="el" href="class_node.html">Node</a> *leftPtr, <a class="el" href="class_node.html">Node</a> *rightPtr)</td></tr>
<tr class="memdesc:a63f4f5083e2a677525a28a5cd194178d inherit pub_methods_class_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for item, and the child objects.  <a href="class_node.html#a63f4f5083e2a677525a28a5cd194178d">More...</a><br /></td></tr>
<tr class="separator:a63f4f5083e2a677525a28a5cd194178d inherit pub_methods_class_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee7aacc0b20abf2301256fe72d0d9cc inherit pub_methods_class_node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node.html#a2ee7aacc0b20abf2301256fe72d0d9cc">setItem</a> (const int &amp;anitem)</td></tr>
<tr class="memdesc:a2ee7aacc0b20abf2301256fe72d0d9cc inherit pub_methods_class_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will set the value for the item.  <a href="class_node.html#a2ee7aacc0b20abf2301256fe72d0d9cc">More...</a><br /></td></tr>
<tr class="separator:a2ee7aacc0b20abf2301256fe72d0d9cc inherit pub_methods_class_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51c74ff8860a12738136be8f1f17682 inherit pub_methods_class_node"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node.html#ad51c74ff8860a12738136be8f1f17682">getItem</a> ()</td></tr>
<tr class="memdesc:ad51c74ff8860a12738136be8f1f17682 inherit pub_methods_class_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will return the item value at that node.  <a href="class_node.html#ad51c74ff8860a12738136be8f1f17682">More...</a><br /></td></tr>
<tr class="separator:ad51c74ff8860a12738136be8f1f17682 inherit pub_methods_class_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4852cb11b6fc5fbb03e110390d0966d inherit pub_methods_class_node"><td class="memItemLeft" align="right" valign="top"><a id="aa4852cb11b6fc5fbb03e110390d0966d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setCount</b> ()</td></tr>
<tr class="separator:aa4852cb11b6fc5fbb03e110390d0966d inherit pub_methods_class_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa9c0a066de25a23670691f6ca99116 inherit pub_methods_class_node"><td class="memItemLeft" align="right" valign="top"><a id="a7fa9c0a066de25a23670691f6ca99116"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getCount</b> ()</td></tr>
<tr class="separator:a7fa9c0a066de25a23670691f6ca99116 inherit pub_methods_class_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5b662d3bfbb856292a9aab878ed622 inherit pub_methods_class_node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node.html#a0c5b662d3bfbb856292a9aab878ed622">isLeaf</a> () const</td></tr>
<tr class="memdesc:a0c5b662d3bfbb856292a9aab878ed622 inherit pub_methods_class_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whill cheak if that node has leaft values.  <a href="class_node.html#a0c5b662d3bfbb856292a9aab878ed622">More...</a><br /></td></tr>
<tr class="separator:a0c5b662d3bfbb856292a9aab878ed622 inherit pub_methods_class_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c225637a0cc1edd73c2aba18ea6f4a inherit pub_methods_class_node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node.html#a81c225637a0cc1edd73c2aba18ea6f4a">getLeftChildPtr</a> ()</td></tr>
<tr class="memdesc:a81c225637a0cc1edd73c2aba18ea6f4a inherit pub_methods_class_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will return the left child pointer at that node.  <a href="class_node.html#a81c225637a0cc1edd73c2aba18ea6f4a">More...</a><br /></td></tr>
<tr class="separator:a81c225637a0cc1edd73c2aba18ea6f4a inherit pub_methods_class_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9db183586c193a33627e239b1cdab5 inherit pub_methods_class_node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node.html#a9f9db183586c193a33627e239b1cdab5">getRightChildPtr</a> ()</td></tr>
<tr class="memdesc:a9f9db183586c193a33627e239b1cdab5 inherit pub_methods_class_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will return the right child pointer at that node.  <a href="class_node.html#a9f9db183586c193a33627e239b1cdab5">More...</a><br /></td></tr>
<tr class="separator:a9f9db183586c193a33627e239b1cdab5 inherit pub_methods_class_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da6acb58d5b8f60bc7ac822250cda32 inherit pub_methods_class_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node.html#a4da6acb58d5b8f60bc7ac822250cda32">setLeftChildPtr</a> (<a class="el" href="class_node.html">Node</a> *leftPtr)</td></tr>
<tr class="memdesc:a4da6acb58d5b8f60bc7ac822250cda32 inherit pub_methods_class_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will set the left child pointer for the item.  <a href="class_node.html#a4da6acb58d5b8f60bc7ac822250cda32">More...</a><br /></td></tr>
<tr class="separator:a4da6acb58d5b8f60bc7ac822250cda32 inherit pub_methods_class_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4994f0037bcc6b52a568de0c0a8acf inherit pub_methods_class_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node.html#a7e4994f0037bcc6b52a568de0c0a8acf">setRightChildPtr</a> (<a class="el" href="class_node.html">Node</a> *rightPtr)</td></tr>
<tr class="memdesc:a7e4994f0037bcc6b52a568de0c0a8acf inherit pub_methods_class_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will set the right child pointer for the node.  <a href="class_node.html#a7e4994f0037bcc6b52a568de0c0a8acf">More...</a><br /></td></tr>
<tr class="separator:a7e4994f0037bcc6b52a568de0c0a8acf inherit pub_methods_class_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5f976e7369dcc91276df40678b59c33c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node_tree.html#a5f976e7369dcc91276df40678b59c33c">removeValue</a> (<a class="el" href="class_node.html">Node</a> *subTreePtr, int target, bool &amp;success)</td></tr>
<tr class="separator:a5f976e7369dcc91276df40678b59c33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68eae12d4ddd719e761e9e96211c8568"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node_tree.html#a68eae12d4ddd719e761e9e96211c8568">removeNode</a> (<a class="el" href="class_node.html">Node</a> *nodePtr)</td></tr>
<tr class="memdesc:a68eae12d4ddd719e761e9e96211c8568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will remove the node.  <a href="#a68eae12d4ddd719e761e9e96211c8568">More...</a><br /></td></tr>
<tr class="separator:a68eae12d4ddd719e761e9e96211c8568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b97fb5f2ea3ed32ec901e1a5589f89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node_tree.html#a56b97fb5f2ea3ed32ec901e1a5589f89">removeLeftmostNode</a> (<a class="el" href="class_node.html">Node</a> *subTreePtr, int &amp;inorderSuccessor)</td></tr>
<tr class="separator:a56b97fb5f2ea3ed32ec901e1a5589f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5897a41812b5694c57140eb5ade884"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_node_tree.html#a3f5897a41812b5694c57140eb5ade884">findNode</a> (<a class="el" href="class_node.html">Node</a> *treePtr, const int &amp;target) const</td></tr>
<tr class="memdesc:a3f5897a41812b5694c57140eb5ade884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will find the node with that value and return the address of it.  <a href="#a3f5897a41812b5694c57140eb5ade884">More...</a><br /></td></tr>
<tr class="separator:a3f5897a41812b5694c57140eb5ade884"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3ad091290982424bcc0750da7133e411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad091290982424bcc0750da7133e411">&#9670;&nbsp;</a></span>~NodeTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NodeTree::~NodeTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor and will call clear to delete the nodes </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2e2cd480e0a50d94d26b09cfd721ac7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2cd480e0a50d94d26b09cfd721ac7a">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NodeTree::add </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>newData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the function used to call the insertInorder function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newData</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>It will take the new data member to give to the insert </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Will create a new node with the data member in it. Then it will pass that new node and the root ptr to add to the tree </dd></dl>

</div>
</div>
<a id="a22be831083f6970a7ba6b64fcd0995ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22be831083f6970a7ba6b64fcd0995ff">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NodeTree::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Will recursively call itself to clear all the children and delete the root </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodePtr</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Will take in the root </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Will clear all the children and nodes recursively </dd></dl>

</div>
</div>
<a id="a7a0617d6f4b39f495da71613a05a098e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0617d6f4b39f495da71613a05a098e">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NodeTree::contains </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>anEntry</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Will check if the tree contains that value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">anEntry</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Will take in a int value to find </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Will call findnode and if that node contains the entry it will return true, else false </dd></dl>

</div>
</div>
<a id="a4a02f5a4836ed05e0d51e946101982b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a02f5a4836ed05e0d51e946101982b8">&#9670;&nbsp;</a></span>deleteNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> * NodeTree::deleteNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>nodePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Will delete the node with the key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodePtr</td><td></td></tr>
    <tr><td class="paramname">key</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nodePtr </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Will take in the root and key to delete that node </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Will recursively call itself and set the children to the correct places after the deletion </dd></dl>

</div>
</div>
<a id="a3f5897a41812b5694c57140eb5ade884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5897a41812b5694c57140eb5ade884">&#9670;&nbsp;</a></span>findNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> * NodeTree::findNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>treePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Will find the node with that value and return the address of it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">treePtr</td><td></td></tr>
    <tr><td class="paramname">target</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>treePtr, will return the address to that target </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Will take in the root and the taret to find it </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Will recursively find the target and return the address of the node </dd></dl>

</div>
</div>
<a id="a28bcd072ea53a04712a792b6b427371c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28bcd072ea53a04712a792b6b427371c">&#9670;&nbsp;</a></span>getEntry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NodeTree::getEntry </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>anEntry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Will find the entry and return the value, if not it will return 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">anEntry</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>anEntry </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Will take in a int value to pass to findnode </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Will call findnode to get the item, and if its the same it will return that value, if not it will return 0 </dd></dl>

</div>
</div>
<a id="a711fa23ec5715b82c1a6dee780fde087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a711fa23ec5715b82c1a6dee780fde087">&#9670;&nbsp;</a></span>getHeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NodeTree::getHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Will get the height by calling the helper. </p>
<dl class="section return"><dt>Returns</dt><dd>The int value given by the helper </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Will chall the helper function to return the number </dd></dl>

</div>
</div>
<a id="ab619ff00f2cd2362d393ad41f2844129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab619ff00f2cd2362d393ad41f2844129">&#9670;&nbsp;</a></span>getNumberofNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NodeTree::getNumberofNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Will return the number of nodes in the tree. It will run until both children get null. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodePtr</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nodes </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Will take the rootptr </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Will recursively call itself and increment the node counter to return the total value. </dd></dl>

</div>
</div>
<a id="a5581b1e229d7310960e826a14e34f560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5581b1e229d7310960e826a14e34f560">&#9670;&nbsp;</a></span>getRootPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> * NodeTree::getRootPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Will return the rootPtr </p><dl class="section return"><dt>Returns</dt><dd>rootPtr </dd></dl>

</div>
</div>
<a id="a504b5d012ccee99b85642d699396dd8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a504b5d012ccee99b85642d699396dd8f">&#9670;&nbsp;</a></span>heightHelper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NodeTree::heightHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>treePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The heightHelper because it can access the rootPtr itself </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">treePtr</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the max height </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Will take the rootptr to pass to the children </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Will recusievly call itself until if finds the nullptr, it will increment itself when it calls itself and returns the max number </dd></dl>

</div>
</div>
<a id="ac57c84edf2b16c3fed7085413b272a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57c84edf2b16c3fed7085413b272a62">&#9670;&nbsp;</a></span>inorderDelete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NodeTree::inorderDelete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>nodePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Will delete the nodes that are equal to the nodes in BTS2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodePtr</td><td></td></tr>
    <tr><td class="paramname">key</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Will take the root and the key </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Will check if the key and the item in that node are equal, if equal it will call delete node to delete that node </dd></dl>

</div>
</div>
<a id="a3973627c8a390da9b12e4bc9d4a9327d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3973627c8a390da9b12e4bc9d4a9327d">&#9670;&nbsp;</a></span>inorderTransverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NodeTree::inorderTransverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Will inorder transverse the tree and print the data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodePtr</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Will get the rootptr to transverse the data </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Will recursively call itself to move through the tree to print it in inorder </dd></dl>

</div>
</div>
<a id="ae6d1c0d70fc02fea199e9e7a81491d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d1c0d70fc02fea199e9e7a81491d83">&#9670;&nbsp;</a></span>insertInorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> * NodeTree::insertInorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>subTreePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>newNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>global variable to count the amount of nodes </p>
<p>Will insert the values into the tree </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTreePtr,pointer</td><td>to the root </td></tr>
    <tr><td class="paramname">newNode,pointer</td><td>the a newNode that contains new value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the root </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Will take in the root pointer and a new node containing the value of the new value </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Will take the root pointer and the new node and set the new node to the right place </dd></dl>

</div>
</div>
<a id="a484735008677b458037b1ce114d12f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484735008677b458037b1ce114d12f1a">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NodeTree::isEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Will test if the tree is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodePtr</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool, if it is empty </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Will take in the root pointer </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Will recursively check if the node points to null, or both children are null </dd></dl>

</div>
</div>
<a id="a71a5469b3871672b409224ee905540c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71a5469b3871672b409224ee905540c3">&#9670;&nbsp;</a></span>minValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> * NodeTree::minValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Will find the min value in the tree </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodePtr</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>current, pointer to the address of the min value </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Will take in the root to find the mon value </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Will run down the left pointers until it finds null and return the address where it is min value </dd></dl>

</div>
</div>
<a id="a09ddf9e2cb245c50952b9669fb328907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ddf9e2cb245c50952b9669fb328907">&#9670;&nbsp;</a></span>postorderTransverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NodeTree::postorderTransverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Will postorder transverse the tree and print the data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodePtr</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Will get the rootptr to transverse the data </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Will recursively call itself to move through the tree to print it in postorder </dd></dl>

</div>
</div>
<a id="a73bd5a18b76a3741fcf49e0465622de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73bd5a18b76a3741fcf49e0465622de2">&#9670;&nbsp;</a></span>preorderTransverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NodeTree::preorderTransverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Will preorder transverse the tree and print the data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodePtr</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Will get the rootptr to transverse the data </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Will recursively call itself to move through the tree to print it in preorder </dd></dl>

</div>
</div>
<a id="a56b97fb5f2ea3ed32ec901e1a5589f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b97fb5f2ea3ed32ec901e1a5589f89">&#9670;&nbsp;</a></span>removeLeftmostNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> * NodeTree::removeLeftmostNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>subTreePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>inorderSuccessor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Will remove the left most <a class="el" href="class_node.html">Node</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTreePtr</td><td></td></tr>
    <tr><td class="paramname">inorderSuccessor</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>will wall the remove node to remove that node </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Will take in the root pointer and the value to set it </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Will get traverse to get to the left most node and then call removeNode to delete it </dd></dl>

</div>
</div>
<a id="a68eae12d4ddd719e761e9e96211c8568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68eae12d4ddd719e761e9e96211c8568">&#9670;&nbsp;</a></span>removeNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> * NodeTree::removeNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>nodePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Will remove the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodePtr</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nodePtr </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Will take in the pointer to delete the node </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Will take the pointer and delete that node and then fill in the gap </dd></dl>

</div>
</div>
<a id="a5f976e7369dcc91276df40678b59c33c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f976e7369dcc91276df40678b59c33c">&#9670;&nbsp;</a></span>removeValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> * NodeTree::removeValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>subTreePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>success</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Will remove a value from the tree </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTreePtr</td><td></td></tr>
    <tr><td class="paramname">target</td><td></td></tr>
    <tr><td class="paramname">success</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer the the node </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Will take in the root , the target and the bool value </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>It will recursively call itself to remove the target and return that pointer </dd></dl>

</div>
</div>
<a id="a4deaf904f4b727579020bcf6cba77a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4deaf904f4b727579020bcf6cba77a8f">&#9670;&nbsp;</a></span>resetCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NodeTree::resetCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Will reset the node value for getNumberofNodes </p><dl class="section post"><dt>Postcondition</dt><dd>Will reset the global variable nodes to 1 </dd></dl>

</div>
</div>
<a id="adfa34cb3970d7ea5ed4c7861ee844b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa34cb3970d7ea5ed4c7861ee844b1e">&#9670;&nbsp;</a></span>setRoot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NodeTree::setRoot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Will rest the rootPtr to a address </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Will take in a node pointer </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Will set the rootPtr to the root address </dd></dl>

</div>
</div>
<a id="aa354f6975e4e1123b47a21948d00e1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa354f6975e4e1123b47a21948d00e1b2">&#9670;&nbsp;</a></span>setRootData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NodeTree::setRootData </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>newData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Will set the s </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newData</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Will take in a in to give to the root ptr </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Will call the constructor for a new node and give the root pointer that data </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_node_tree_8h_source.html">NodeTree.h</a></li>
<li>NodeTree.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
